import os
from collections import defaultdict


# the file path of the input sequence to annotate
seq = config['seq']

# =============================================================================
# Prodigal
# =============================================================================
rule prodigal:
    '''Predict CDS with Prodigal.

    References
    ----------
    Hyatt, D., Chen, G.-L., LoCascio, P.F., Land, M.L., Larimer, F.W., and
    Hauser, L.J. (2010). Prodigal: prokaryotic gene recognition and
    translation initiation site identification. BMC Bioinformatics 11, 119.
    '''
    input:
        seq
    output:
        ok = touch('prodigal.ok'),
        gff = 'prodigal.gff',
        faa = os.path.splitext(seq)[0] + '.faa',
        fna = 'prodigal.fna',
    log:
        'prodigal.log'
    params:
        '-f gff -g {gcode} {PRODIGAL_MODE}'.format(
            **config,
            PRODIGAL_MODE=dict(finished='-p single -c',
                                draft='-p single',
                                metagenome='-p meta')[config['mode']])
    priority:
         config.get('prodigal', {}).get('priority', 0)
    shell:
        'prodigal {params} -i {input[0]} -o {output.gff} -a {output.faa} -d {output.fna} &> {log}'


rule prodigal_coords:
    '''Create .coords file (from prodigal output) required by TransTermHP'''
    input:
        gff = rules.prodigal.output.gff
    output:
        coords = 'prodigal.coords'
    run:
        with open(input.gff) as f, open(output.coords, 'w') as out:
            for line in f:
                if line.startswith('#'):
                    continue
                items = line.split('\t')
                strand = items[6]
                start, end = items[3], items[4]
                if strand == '-':
                    start, end = end, start
                gene_id = items[-1].split(';')[0].split('=')[1]
                out.write('{}\t{}\t{}\t{}\n'.format(
                    gene_id, start, end, items[0]))


# =============================================================================
# TransTermHP
# =============================================================================
rule transtermhp:
    '''Predict rho-independent transcription terminators with TransTermHP.

    References
    ----------
    C. Kingsford, K. Ayanbule and S.L. Salzberg. Rapid, accurate,
    computational discovery of Rho-independent transcription terminators
    illuminates their relationship to DNA uptake. Genome Biology 8:R22
    (2007).

    http://transterm.cbcb.umd.edu/index.php
    '''
    input:
        seq, rules.prodigal_coords.output.coords
    output:
        'transtermhp.txt',
        ok = touch('transtermhp.ok')
    log:
        'transtermhp.log'
    params:
        '-p $TRANSTERMHP'
        # '--all-context'  # output all predicted terminators instead of legitimate ones
    priority:
        config.get('transtermhp', {}).get('priority', 0)
    shell:
        'transterm {params} {input[0]} {input[1]} > {output[0]} 2> {log}'

# =============================================================================
# MINCED
# =============================================================================
rule minced:
    '''Predict CRISPR with minced.'''
    input:
        fna = seq
    output:
        'minced.gff',
        ok = touch('minced.ok')
    log:
        'minced.log'
    params:
        '-gff'
    priority:
        config.get('minced', {}).get('priority', 0)
    shell:
        'minced {params} {input.fna} {output[0]} &> {log}'


# =============================================================================
# ARAGORN
# =============================================================================
rule aragorn:
    '''Predict tRNA with Aragorn.'''
    input:
        fna = seq
    output:
        'aragorn.txt',
        ok = touch('aragorn.ok')
    log:
        'aragorn.log'
    params:
        '-w -gc{gcode}'.format(**config)
    priority:
        config.get('aragorn', {}).get('priority', 0)
    shell:
        'aragorn {params} -o {output[0]} {input.fna} &> {log}'


rule cmscan:
    '''Predict ncRNA with cmscan and Rfam.'''
    input:
        db = config.get('cmscan', {}).get('db', ''),
        fna = seq
    output:
        # this is expansive to compute. protect it so it is not overwritten accidentally
        protected('cmscan.txt'),
        ok = touch('cmscan.ok')
    log:
        'cmscan.log'
    threads:
        config.get('cmscan', {}).get('threads', 1)
    params:
        ''
    priority:
        config.get('cmscan', {}).get('priority', 0)
    shell:
        'cmscan {params} --cpu {threads} --tblout {output[0]} {input.db} {input.fna} &> {log}'


rule tandem_repeats_finder:
    '''Predict tandem repeats with TRF.

    References
    ----------
    Tandem repeats finder: a program to analyze DNA sequences
    Nucleic Acid Research(1999)
    Vol. 27, No. 2, pp. 573-580.

    http://tandem.bu.edu/trf/trf.html
    '''
    input:
        seq
    output:
        'tandem_repeats_finder.txt',
        ok = touch('tandem_repeats_finder.ok')
    log:
        'tandem_repeats_finder.log'
    params:
        # use recommended parameters
        '2 7 7 80 10 50 500 -h -ngs'
    priority:
        config.get('tandem_repeats_finder', {}).get('priority', 0)
    shell:
        'trf {input[0]} {params} > {output[0]} 2> {log}'


rule cmscan_rRNA:
    '''Predict rRNA with cmscan.'''
    input:
        db = config.get('cmscan_rRNA', {}).get('db', ''),
        fna = seq
    output:
        'cmscan_rRNA.txt',
        ok = touch('cmscan_rRNA.ok')
    log:
        'cmscan_rRNA.log'
    threads:
        config.get('cmscan_rRNA', {}).get('threads', 1)
    params:
        ''
    priority:
        config.get('cmscan_rRNA', {}).get('priority', 1)
    shell:
        'cmscan {params} --cpu {threads} --tblout {output[0]} {input.db} {input.fna} &> {log}'


rule rnammer:
    '''Predict rRNA with RNAmmer.'''
    input:
        fna = seq
    output:
        'rnammer.gff',
        ok = touch('rnammer.ok')
    params:
        # use bac, arc, and euk (3 letters) for -S param
        '-m lsu,ssu,tsu -S {RNAMMER_KINGDOM}'.format(RNAMMER_KINGDOM=config['kingdom'][:3])
    shell:
        'rnammer {params} -gff {output[0]} {input.fna}'


# =============================================================================
# diamond_uniref90/50
# protein homologous annotation using diamond and uniref
# =============================================================================
from micronota.util import _filter_sequence_ids


rule diamond_uniref90:
    '''Homologous search UniRef90 with Diamond blastp.'''
    input:
        db = config.get('diamond_uniref90', {}).get('db', ''),
        faa = rules.prodigal.output['faa']
    output:
        protected('diamond_uniref90.m13')
    log:
        'diamond_uniref90.log'
    priority:
        config.get('diamond_uniref90', {}).get('priority', 0)
    params:
        '--index-chunks 1 --id 90 --subject-cover 80 --query-cover 80 --max-target-seqs 3'
    threads:
        config.get('diamond_uniref90', {}).get('threads', 1)
    shell:
        'diamond blastp {params} --threads {threads}'
        ' --db {input.db} -q {input.faa} -o {output[0]}'
        ' --outfmt 6 qseqid qlen sseqid slen pident length gaps'
        ' evalue bitscore qstart qend sstart send &> {log} && '
        'cat {output[0]} >> diamond.hit'

rule unmatched_uniref90:
    '''Filter out the proteins that don't hit UniRef90'''
    input:
        rules.diamond_uniref90.output[0],
        rules.diamond_uniref90.input['faa']
    output:
        faa = 'diamond_uniref90_unmatched.faa'
    run:
        with open(input[0]) as fh:
            ids = [line.split('\t')[0] for line in fh]
        _filter_sequence_ids(input[1], output.faa, ids)


rule diamond_uniref50:
    '''Homologous search UniRef50 with Diamond blastp.'''
    input:
        db = config.get('diamond_uniref50', {}).get('db', ''),
        faa = rules.unmatched_uniref90.output.faa
    output:
        protected('diamond_uniref50.m13')
    log:
        'diamond_uniref50.log'
    priority:
        config.get('diamond_uniref50', {}).get('priority', 0)
    params:
        '--index-chunks 1 --id 50 --subject-cover 80 --query-cover 80 --max-target-seqs 3'
    threads:
        config.get('diamond_uniref50', {}).get('threads', 1)
    shell:
        'diamond blastp {params} --threads {threads}'
        ' --db {input.db} -q {input.faa} -o {output[0]}'
        ' --outfmt 6 qseqid qlen sseqid slen pident length gaps'
        ' evalue bitscore qstart qend sstart send &> {log} && '
        'cat {output[0]} >> diamond.hit'

rule unmatched_uniref50:
    '''Filter out the proteins that don't hit UniRef50'''
    input:
        rules.diamond_uniref50.output[0],
        rules.unmatched_uniref90.output['faa']
    output:
        faa = 'diamond_uniref50_unmatched.faa',
        ok = touch('diamond_uniref.ok')
    run:
        with open(input[0]) as fh:
            ids = [line.split('\t')[0] for line in fh]
        _filter_sequence_ids(input[1], output.faa, ids)


# rule all:
#     input:
#         rules.prodigal.output['ok'],
#         rules.minced.output['ok'],
#         rules.transtermhp.output['ok'],
#         rules.rnammer.output['ok'],
#         rules.diamond_uniref50.output['ok']
