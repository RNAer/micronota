from collections import defaultdict

default = defaultdict(str)
seq = config['seq']
genetic_code = config['genetic_code']
kingdom = config['kingdom']

outputs = []
for task in config['structural_annotation']:
    rule_config = config['structural_annotation'][task]
    outputs.append('%s.ok' % task)

for task in config['protein']:
    rule_config = config['protein'][task]
    outputs.append('%s.hit' % rule_config['output'])
    include: '%s.rule' % task

for task in config.get(kingdom, []):
    rule_config = config[kingdom][task]
    outputs.append('%s.ok' % task)

rule all:
    input:
        outputs


prodigal = config['structural_annotation'].get('prodigal', default)
rule prodigal:
    '''Predict CDS with Prodigal.

    References
    ----------
    Hyatt, D., Chen, G.-L., LoCascio, P.F., Land, M.L., Larimer, F.W., and
    Hauser, L.J. (2010). Prodigal: prokaryotic gene recognition and
    translation initiation site identification. BMC Bioinformatics 11, 119.

    '''
    input:
        seq
    output:
        touch('prodigal.ok'),
        gff = 'prodigal.txt',
        faa = 'prodigal.faa',
        fna = 'prodigal.fna',
    log:
        'prodigal.log'
    params:
        prodigal['params']
    priority:
        prodigal['priority']
    shell:
        'prodigal {params} -f gff -g %d -i {input[0]} -o {output.gff}'
        ' -a {output.faa} -d {output.fna} &> {log}' % genetic_code

rule prodigal_coords:
    '''Create .coords file required by TransTermHP'''
    input:
        gff = rules.prodigal.output.gff
    output:
        coords = 'prodigal.coords'
    priority:
        prodigal['priority']
    run:
        with open(input.gff) as f, open(output.coords, 'w') as out:
            for line in f:
                if line.startswith('#'):
                    continue
                items = line.split('\t')
                strand = items[6]
                start, end = items[3], items[4]
                if strand == '-':
                    start, end = end, start
                gene_id = items[-1].split(';')[0].split('=')[1]
                out.write('{}\t{}\t{}\t{}\n'.format(
                    gene_id, start, end, items[0]))


transtermhp = config['structural_annotation'].get('transtermhp', default)
rule TransTermHP:
    '''Predict rho-independent transcription terminators with TransTermHP.

    References
    ----------
    C. Kingsford, K. Ayanbule and S.L. Salzberg. Rapid, accurate,
    computational discovery of Rho-independent transcription terminators
    illuminates their relationship to DNA uptake. Genome Biology 8:R22
    (2007).

    http://transterm.cbcb.umd.edu/index.php
    '''
    input:
        seq, rules.prodigal_coords.output.coords
    output:
        tt = 'transtermhp.txt',
        ok  = touch('transtermhp.ok')
    log:
        'transtermhp.log'
    params:
        transtermhp['params']
    priority:
        transtermhp['priority']
    shell:
        'transterm {params} {input[0]} {input[1]} > {output.tt} 2> {log}'


minced = config['structural_annotation'].get('minced', default)
rule minced:
    '''Predict CRISPR with minced.'''
    input:
        fna = seq
    output:
        'minced.txt', touch('minced.ok')
    log:
        'minced.log'
    params:
        minced['params']
    priority:
        minced['priority']
    shell:
        'minced {params} -gff {input.fna} {output[0]} &> {log}'


aragorn = config['structural_annotation'].get('aragorn', default)
rule aragorn:
    '''Predict tRNA with Aragorn.'''
    input:
        fna = seq
    output:
        'aragorn.txt', touch('aragorn.ok')
    log:
        'aragorn.log'
    params:
        aragorn['params']
    priority:
        aragorn['priority']
    shell:
        'aragorn {params} -gc%r -o {output[0]} {input.fna} &> {log}' % genetic_code


cmscan = config['structural_annotation'].get('cmscan', defaultdict(str))
rule cmscan:
    '''Predict ncRNA with cmscan and Rfam.'''
    input:
        db = cmscan['db'],
        fna = seq
    output:
        protected('cmscan.txt'), touch('cmscan.ok')
    log:
        'cmscan.log'
    threads:
        cmscan['threads']
    params:
        cmscan['params']
    priority:
        cmscan['priority']
    shell:
        'cmscan {params} --cpu {threads} --tblout {output[0]} {input.db} {input.fna} &> {log}'


tandem_repeats_finder = config['structural_annotation'].get('tandem_repeats_finder', default)
rule tandem_repeats_finder:
    '''Predict tandem repeats with TRF.

    References
    ----------
    Tandem repeats finder: a program to analyze DNA sequences
    Nucleic Acid Research(1999)
    Vol. 27, No. 2, pp. 573-580.

    http://tandem.bu.edu/trf/trf.html
    '''
    input:
        seq
    output:
        'tandem_repeats_finder.txt', touch('tandem_repeats_finder.ok')
    log:
        'tandem_repeats_finder.log'
    params:
        tandem_repeats_finder['params']
    priority:
        tandem_repeats_finder['priority']
    shell:
        # use recommended parameters
        'trf {input[0]} 2 7 7 80 10 50 500 -h -ngs > {output[0]} 2> {log}'


cmscan_rRNA = config[kingdom].get('cmscan.rRNA', default)
rule cmscan_rRNA:
    '''Predict rRNA with cmscan.'''
    input:
        db = cmscan_rRNA['db'],
        fna = seq
    output:
        'cmscan.rRNA.txt', touch('cmscan.rRNA.ok')
    log:
        'cmscan.rRNA.log'
    threads:
        cmscan_rRNA['threads']
    params:
        cmscan_rRNA['params']
    priority:
        cmscan_rRNA['priority']
    shell:
        'cmscan {params} --cpu {threads} --tblout {output[0]} {input.db} {input.fna} &> {log}'

# rule report:
#     input:
#         '{seq}.gff'
#     output:
#         "{seq}.html"
#     run:
#         from snakemake.utils import report
#         shell('touch {output[0]}')
